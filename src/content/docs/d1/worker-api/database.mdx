---
title: D1 database
pcx_content_type: concept
sidebar:
  order: 1
---

import { Type, MetaInfo, Details } from "~/components";

## Description

You can execute queries on your D1 database through SQL statements.

### TypeScript support

D1 Worker Bindings API is fully-typed via the `@cloudflare/workers-types` package, and also supports [generic types](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-types) as part of its TypeScript API. A generic type allows you to provide an optional _type parameter_ so that a function understands the type of the data it is handling.

When using the [query statement methods](#query-statement-methods) `stmt.all()`, `stmt.raw()` and `stmt.first()`, you can provide a type representing each database row. D1's API will [return the result object](#return-object) with the correct type.

For example, providing an `OrderRow` type as a type parameter to `stmt.all()` will return a typed `Array<OrderRow>` object instead of the default `Record<string, unknown>` type:

```ts
// Row definition
type OrderRow = {
	Id: string;
	CustomerName: string;
	OrderDate: number;
};

// Elsewhere in your application
const result = await env.MY_DB.prepare(
	"SELECT Id, CustomerName, OrderDate FROM [Order] ORDER BY ShippedDate DESC LIMIT 100",
).all<OrderRow>();
```

## Methods

### `db.prepare()`

D1 API supports both prepared and static statements.

- Prepared statements are SQL statements where the variables are dynamically determined. When writing a prepared statement, you insert variables into placeholders within the statement string.
- Static statements are SQL statements where the variables have been hard coded. When writing a static statement, you manually type the variable within the statement string.

The recommended approach is to use prepared statements (which are precompiled objects used by the database) to run the SQL. Prepared statements lead to faster overall execution and prevent SQL injection attacks.

Example of a prepared statement:

```js
const stmt = db.prepare("SELECT * FROM users WHERE name = ?1").bind(someVariable);
// A variable (someVariable) will replace the placeholder '?1' in the query.
// This is a prepared statement.
```

Example of a static statement:

```js
const stmt = db.prepare('SELECT * FROM users WHERE name = "John Doe"');
// "John Doe" is hard-coded into the query.
// This is a static statement.
```

#### Parameters

- <code>sqlQuery</code>: <Type text="String"/> <MetaInfo text="Required"/>
  - The SQL query you wish to execute on the database.

#### Return values

- <code>queryResult</code>:
  - The result of the SQL query.

#### Guidance

- You can pass multiple queries into a single `.prepare()` statement. Simply delineate each query with a semi-colon.
  - The statement only returns the results of the last query, even though all queries are executed.
  - You can only pass parameters to the last query.
	```js
	const stmt = db.prepare(`SELECT * FROM users WHERE name = "Anthony"; SELECT * FROM users WHERE name = ?1`).bind("Joe")
	```
- D1 follows the [SQLite convention](https://www.sqlite.org/lang_expr.html#varparam) for prepared statements parameter binding. Currently, D1 only supports Ordered (`?NNNN`) and Anonymous (`?`) parameters. In the future, D1 will support named parameters as well.

	| Syntax | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
	| ------ | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	| `?NNN` | Ordered   | A question mark followed by a number `NNN` holds a spot for the `NNN`-th parameter. `NNN` must be between `1` and `SQLITE_MAX_VARIABLE_NUMBER`                                                                                                                                                                                                                                                                                                                                                                                                    |
	| `?`    | Anonymous | A question mark that is not followed by a number creates a parameter with a number one greater than the largest parameter number already assigned. If this means the parameter number is greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. This parameter format is provided for compatibility with other database engines. But because it is easy to miscount the question marks, the use of this parameter format is discouraged. Programmers are encouraged to use one of the symbolic formats below or the `?NNN` format above instead |

	To bind a parameter, use the `stmt.bind()` method.

	Order and anonymous examples:

	```js
	const stmt = db.prepare("SELECT * FROM users WHERE name = ?").bind("John Doe");
	```

	```js
	const stmt = db
		.prepare("SELECT * FROM users WHERE name = ? AND age = ?")
		.bind("John Doe", 41);
	```

	```js
	const stmt = db
		.prepare("SELECT * FROM users WHERE name = ?2 AND age = ?1")
		.bind(41, "John Doe");
	```

### `db.batch()`

Batching sends multiple SQL statements inside a single call to the database. This can have a huge performance impact as it reduces latency from network round trips to D1. D1 operates in auto-commit. Our implementation guarantees that each statement in the list will execute and commit, sequentially, non-concurrently.

Batched statements are [SQL transactions](https://www.sqlite.org/lang_transaction.html). If a statement in the sequence fails, then an error is returned for that specific statement, and it aborts or rolls back the entire sequence.

To send batch statements, provide `.batch()` a list of prepared statements and get the results in the same order.

```js
await db.batch([
  db.prepare("UPDATE users SET name = ?1 WHERE id = ?2").bind("John", 17),
  db.prepare("UPDATE users SET age = ?1 WHERE id = ?2").bind(35, 19),
]);
```

#### Parameters

- <code>statements</code>: <Type text="Array"/>
  - An array of `db.prepare()` statements.

#### Return values

- <code>results</code>: <Type text="Array"/>
  - An array of objects containing the results of the `.db.prepare()` statements. Each object is in the array position corresponding to the array position of the initial `db.prepare()` statement within the `statementArray`.
  - For more information on the returned object, refer to [Return objects](/d1/worker-api/return-object).

<Details header="Example of return values" open={false}>

```js
const rows = await db.batch([
	db.prepare("SELECT * FROM users WHERE name = ?1").bind("John"),
	db.prepare("SELECT * FROM users WHERE name = ?1").bind("Anthony")
	]);
```
```js
console.log(rows[0].results);
```
```js output
[
  {
     name: "John Clemente",
     age: 42,
  },
   {
     name: "John Davis",
     age: 37,
  },
 ]
```
```js
console.log(rows[1].results);
```
```js output
[
  {
     name: "Anthony Hopkins",
     age: 66,
  },
 ]
```
</Details>

#### Guidance

- You can construct batches reusing the same prepared statement:

	```js
	const stmt = db.prepare("SELECT * FROM users WHERE name = ?1");

	const rows = await db.batch([stmt.bind("John"), stmt.bind("Anthony")]);
	```

### `db.exec()`

Executes one or more queries directly without prepared statements or parameters binding.

```js
const migration = await fetch("/migration.sql");
const out = await db.exec(migration.text());
```

#### Parameters

-

#### Return values

- <code>queryResult</code>: <Type text="Any"/>
  - Result of the query.

<Details header="Example of return values" open={false}>
```js
const migration = await fetch("/migration.sql");
const out = await db.exec(migration.text());
console.log(out);
```
```js output
{
  count: 80,
  duration: 76
}
```
</Details>

#### Guidance

- If an error occurs, an exception is thrown with the query and error messages, execution stops and further statements are not executed. Refer to [Errors](/d1/build-with-d1/d1-client-api/#errors) to learn more.
- This method can have poorer performance (prepared statements can be reused in some cases) and, more importantly, is less safe.
- Only use this method for maintenance and one-shot tasks (for example, migration jobs).
- The input can be one or multiple queries separated by `\n`.

### `db.dump`

:::caution
This API only works on databases created during D1's alpha period. Check which version your database uses with `wrangler d1 info <DATABASE_NAME>`.
:::

Dumps the entire D1 database to an SQLite compatible file inside an ArrayBuffer.

```js
const dump = await db.dump();
return new Response(dump, {
	status: 200,
	headers: {
		"Content-Type": "application/octet-stream",
	},
});
```

#### Parameters

-

#### Return values

-

